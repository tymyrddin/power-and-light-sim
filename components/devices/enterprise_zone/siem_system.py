# components/devices/enterprise_zone/siem_system.py
"""
Security Information and Event Management (SIEM) System.

Consumes and analyzes the audit trail from ICSLogger to detect security
incidents, correlate events, and generate alerts.

Features:
- Real-time audit trail monitoring
- Security event correlation
- Anomaly detection (failed auth, unusual access patterns)
- Alert generation and prioritization
- Incident tracking
- Compliance reporting
"""

import asyncio
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any

from components.devices.core.base_device import BaseDevice
from components.security.logging_system import (
    AlarmPriority,
    AlarmState,
    EventCategory,
    EventSeverity,
)
from components.state.data_store import DataStore

__all__ = ["SIEMSystem", "SIEMAlert", "AlertSeverity", "IncidentStatus"]


class AlertSeverity(Enum):
    """SIEM alert severity levels."""

    CRITICAL = 1  # Immediate response required
    HIGH = 2  # Urgent investigation needed
    MEDIUM = 3  # Should be investigated
    LOW = 4  # Informational, awareness
    INFO = 5  # Normal activity logged


class IncidentStatus(Enum):
    """Security incident status."""

    NEW = "new"  # Newly detected
    INVESTIGATING = "investigating"  # Under investigation
    CONTAINED = "contained"  # Threat contained
    RESOLVED = "resolved"  # Incident resolved
    FALSE_POSITIVE = "false_positive"  # Not a real threat


@dataclass
class SIEMAlert:
    """Security alert generated by SIEM."""

    alert_id: str
    severity: AlertSeverity
    category: str
    title: str
    description: str
    detection_time: float  # Simulation time
    wall_time: float

    # Evidence
    events: list[dict[str, Any]] = field(default_factory=list)
    affected_devices: list[str] = field(default_factory=list)
    indicators: dict[str, Any] = field(default_factory=dict)

    # Status
    status: IncidentStatus = IncidentStatus.NEW
    assigned_to: str = ""
    notes: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert alert to dictionary."""
        return {
            "alert_id": self.alert_id,
            "severity": self.severity.name,
            "category": self.category,
            "title": self.title,
            "description": self.description,
            "detection_time": self.detection_time,
            "wall_time": self.wall_time,
            "events_count": len(self.events),
            "affected_devices": self.affected_devices,
            "indicators": self.indicators,
            "status": self.status.value,
            "assigned_to": self.assigned_to,
            "notes": self.notes,
        }


class SIEMSystem(BaseDevice):
    """
    Security Information and Event Management system.

    Monitors audit trail for security incidents and generates alerts.

    Detection Rules:
    - Multiple failed authentication attempts
    - Unauthorized access attempts (network segmentation violations)
    - Safety bypass operations
    - Unusual write patterns to critical devices
    - Protocol anomalies
    - Privilege escalation attempts

    Example:
        >>> siem = SIEMSystem(
        ...     device_name="siem_main",
        ...     device_id=1000,
        ...     data_store=data_store,
        ...     analysis_interval=5.0
        ... )
        >>> await siem.start()
        >>> alerts = await siem.get_active_alerts()
    """

    def __init__(
        self,
        device_name: str,
        device_id: int,
        data_store: DataStore,
        description: str = "SIEM System",
        analysis_interval: float = 5.0,  # Analyze every 5 seconds
        alert_history_limit: int = 1000,
        log_dir: Path | None = None,
    ):
        """
        Initialize SIEM system.

        Args:
            device_name: Unique device identifier
            device_id: Numeric device ID
            data_store: Reference to DataStore
            description: Human-readable description
            analysis_interval: How often to analyze audit trail (seconds)
            alert_history_limit: Maximum alerts to retain
            log_dir: Directory for log files
        """
        super().__init__(
            device_name=device_name,
            device_id=device_id,
            data_store=data_store,
            description=description,
            scan_interval=analysis_interval,
            log_dir=log_dir,
        )

        self.analysis_interval = analysis_interval
        self.alert_history_limit = alert_history_limit

        # Alert storage
        self.alerts: list[SIEMAlert] = []
        self.alert_count_by_severity: dict[AlertSeverity, int] = defaultdict(int)

        # Tracking for pattern detection
        self._last_processed_event_index = 0
        self._failed_auth_attempts: dict[str, list[float]] = defaultdict(list)
        self._device_write_counts: dict[str, int] = defaultdict(int)
        self._network_denials: dict[str, list[float]] = defaultdict(list)
        self._safety_bypasses: dict[str, list[dict]] = defaultdict(list)

        # Statistics
        self.total_events_analyzed = 0
        self.total_alerts_generated = 0

        self.logger.info(
            f"SIEM system initialized: analysis_interval={analysis_interval}s, "
            f"alert_limit={alert_history_limit}"
        )

    # ----------------------------------------------------------------
    # BaseDevice abstract methods
    # ----------------------------------------------------------------

    def _device_type(self) -> str:
        """Return device type."""
        return "siem_system"

    def _supported_protocols(self) -> list[str]:
        """SIEM doesn't expose ICS protocols."""
        return ["syslog", "http_api"]

    async def _initialise_memory_map(self) -> None:
        """Initialize memory map with SIEM statistics."""
        self.memory_map = {
            "total_events_analyzed": 0,
            "total_alerts_generated": 0,
            "active_alerts": 0,
            "critical_alerts": 0,
            "high_alerts": 0,
            "medium_alerts": 0,
            "low_alerts": 0,
        }

    async def _scan_cycle(self) -> None:
        """
        Periodic security analysis cycle.

        Fetches new audit trail events and runs detection rules.
        """
        try:
            # Fetch audit trail events we haven't seen yet
            all_events = await self.data_store.get_audit_log(limit=None)

            # Process new events
            new_events = all_events[self._last_processed_event_index:]

            if new_events:
                self.total_events_analyzed += len(new_events)
                self._last_processed_event_index = len(all_events)

                # Run detection rules
                await self._analyze_events(new_events)

                # Update memory map
                await self._update_statistics()

                self.logger.debug(
                    f"Analyzed {len(new_events)} new events, "
                    f"{len(self.get_active_alerts())} active alerts"
                )

        except Exception as e:
            self.logger.error(f"Error in SIEM analysis cycle: {e}", exc_info=True)
            self.metadata["error_count"] += 1

    # ----------------------------------------------------------------
    # Event analysis and detection
    # ----------------------------------------------------------------

    async def _analyze_events(self, events: list[dict[str, Any]]) -> None:
        """
        Analyze events and generate alerts.

        Args:
            events: List of audit trail events to analyze
        """
        for event in events:
            # Extract event details
            action = event.get("data", {}).get("action", "")
            result = event.get("data", {}).get("result", "")
            device = event.get("device", "")
            user = event.get("user", "")
            sim_time = event.get("simulation_time", 0.0)

            # Detection Rule 1: Failed authentication attempts
            if action in ["authorize", "login", "authenticate"] and result == "FAILED":
                await self._detect_failed_auth(user, device, sim_time, event)

            # Detection Rule 2: Network segmentation violations
            if "denied by network segmentation" in event.get("message", ""):
                await self._detect_network_violation(event, sim_time)

            # Detection Rule 3: Safety bypass operations
            if action in ["activate_safety_bypass", "deactivate_safety_bypass"]:
                await self._detect_safety_bypass(event, sim_time)

            # Detection Rule 4: SCRAM operations
            if "scram" in action.lower():
                await self._detect_scram_event(event, sim_time)

            # Detection Rule 5: High-frequency writes to critical devices
            if "write" in action.lower() and device:
                await self._detect_unusual_write_pattern(device, sim_time, event)

    async def _detect_failed_auth(
        self, user: str, device: str, sim_time: float, event: dict
    ) -> None:
        """Detect multiple failed authentication attempts."""
        if not user:
            return

        # Track failed attempts per user
        self._failed_auth_attempts[user].append(sim_time)

        # Keep only recent attempts (last 60 simulation seconds)
        self._failed_auth_attempts[user] = [
            t for t in self._failed_auth_attempts[user] if sim_time - t < 60.0
        ]

        # Alert if 3+ failures in 60 seconds
        if len(self._failed_auth_attempts[user]) >= 3:
            await self._generate_alert(
                severity=AlertSeverity.HIGH,
                category="authentication",
                title=f"Multiple failed authentication attempts: {user}",
                description=f"User '{user}' has {len(self._failed_auth_attempts[user])} "
                           f"failed authentication attempts in the last 60 seconds",
                events=[event],
                affected_devices=[device] if device else [],
                indicators={
                    "user": user,
                    "failure_count": len(self._failed_auth_attempts[user]),
                    "time_window": "60s",
                },
                sim_time=sim_time,
            )

            # Clear to avoid duplicate alerts
            self._failed_auth_attempts[user] = []

    async def _detect_network_violation(self, event: dict, sim_time: float) -> None:
        """Detect network segmentation violations."""
        source = event.get("data", {}).get("source_network", "unknown")
        device = event.get("device", "unknown")
        key = f"{source}->{device}"

        # Track violations
        self._network_denials[key].append(sim_time)

        # Keep recent (last 120 seconds)
        self._network_denials[key] = [
            t for t in self._network_denials[key] if sim_time - t < 120.0
        ]

        # Alert if 5+ denials in 120 seconds (potential reconnaissance)
        if len(self._network_denials[key]) >= 5:
            await self._generate_alert(
                severity=AlertSeverity.MEDIUM,
                category="network_security",
                title=f"Network segmentation violations: {source} -> {device}",
                description=f"Multiple attempts ({len(self._network_denials[key])}) to "
                           f"bypass network segmentation from {source} to {device}",
                events=[event],
                affected_devices=[device],
                indicators={
                    "source_network": source,
                    "target_device": device,
                    "violation_count": len(self._network_denials[key]),
                },
                sim_time=sim_time,
            )

            self._network_denials[key] = []

    async def _detect_safety_bypass(self, event: dict, sim_time: float) -> None:
        """Detect safety system bypass operations."""
        device = event.get("device", "")
        action = event.get("data", {}).get("action", "")
        user = event.get("user", "")

        # Track bypasses per device
        self._safety_bypasses[device].append({
            "time": sim_time,
            "action": action,
            "user": user,
            "event": event,
        })

        # Always alert on bypass activation (HIGH priority)
        if action == "activate_safety_bypass":
            await self._generate_alert(
                severity=AlertSeverity.HIGH,
                category="safety",
                title=f"Safety bypass activated: {device}",
                description=f"Safety system bypass activated on {device} by {user}",
                events=[event],
                affected_devices=[device],
                indicators={
                    "device": device,
                    "user": user,
                    "action": action,
                },
                sim_time=sim_time,
            )

    async def _detect_scram_event(self, event: dict, sim_time: float) -> None:
        """Detect reactor SCRAM operations."""
        device = event.get("device", "")
        action = event.get("data", {}).get("action", "")

        # SCRAM is always a critical event
        await self._generate_alert(
            severity=AlertSeverity.CRITICAL,
            category="safety",
            title=f"Reactor SCRAM: {device}",
            description=f"Reactor SCRAM operation detected on {device}: {action}",
            events=[event],
            affected_devices=[device],
            indicators={
                "device": device,
                "action": action,
            },
            sim_time=sim_time,
        )

    async def _detect_unusual_write_pattern(
        self, device: str, sim_time: float, event: dict
    ) -> None:
        """Detect high-frequency write operations to devices."""
        self._device_write_counts[device] += 1

        # Alert if a device has excessive writes (>50 in scan interval)
        # This could indicate automated attack or malfunction
        if self._device_write_counts[device] > 50:
            await self._generate_alert(
                severity=AlertSeverity.MEDIUM,
                category="anomaly",
                title=f"Unusual write activity: {device}",
                description=f"Device {device} has received {self._device_write_counts[device]} "
                           f"write operations in {self.analysis_interval}s interval",
                events=[event],
                affected_devices=[device],
                indicators={
                    "device": device,
                    "write_count": self._device_write_counts[device],
                    "interval": self.analysis_interval,
                },
                sim_time=sim_time,
            )

            # Reset counter after alert
            self._device_write_counts[device] = 0

    # ----------------------------------------------------------------
    # Alert management
    # ----------------------------------------------------------------

    async def _generate_alert(
        self,
        severity: AlertSeverity,
        category: str,
        title: str,
        description: str,
        events: list[dict],
        affected_devices: list[str],
        indicators: dict[str, Any],
        sim_time: float,
    ) -> SIEMAlert:
        """Generate and store a security alert."""
        import time

        alert = SIEMAlert(
            alert_id=f"SIEM-{self.total_alerts_generated + 1:06d}",
            severity=severity,
            category=category,
            title=title,
            description=description,
            detection_time=sim_time,
            wall_time=time.time(),
            events=events,
            affected_devices=affected_devices,
            indicators=indicators,
        )

        self.alerts.append(alert)
        self.alert_count_by_severity[severity] += 1
        self.total_alerts_generated += 1

        # Trim history if needed
        if len(self.alerts) > self.alert_history_limit:
            oldest = self.alerts[0]
            self.alerts = self.alerts[-self.alert_history_limit:]
            self.logger.debug(f"Trimmed alert history, removed {oldest.alert_id}")

        # Log alert generation
        await self.logger.log_alarm(
            message=f"SIEM Alert: {title}",
            priority=self._severity_to_alarm_priority(severity),
            state=AlarmState.ACTIVE,
            device=self.device_name,
            data={
                "alert_id": alert.alert_id,
                "category": category,
                "affected_devices": affected_devices,
                "indicators": indicators,
            },
        )

        self.logger.warning(
            f"Generated {severity.name} alert: {title} ({alert.alert_id})"
        )

        return alert

    def _severity_to_alarm_priority(self, severity: AlertSeverity) -> AlarmPriority:
        """Map SIEM severity to alarm priority."""
        mapping = {
            AlertSeverity.CRITICAL: AlarmPriority.CRITICAL,
            AlertSeverity.HIGH: AlarmPriority.HIGH,
            AlertSeverity.MEDIUM: AlarmPriority.MEDIUM,
            AlertSeverity.LOW: AlarmPriority.LOW,
            AlertSeverity.INFO: AlarmPriority.LOW,
        }
        return mapping.get(severity, AlarmPriority.MEDIUM)

    def get_active_alerts(
        self, severity: AlertSeverity | None = None
    ) -> list[SIEMAlert]:
        """
        Get active alerts (NEW or INVESTIGATING status).

        Args:
            severity: Optional filter by severity

        Returns:
            List of active alerts
        """
        active = [
            a for a in self.alerts
            if a.status in (IncidentStatus.NEW, IncidentStatus.INVESTIGATING)
        ]

        if severity:
            active = [a for a in active if a.severity == severity]

        return active

    def get_all_alerts(
        self,
        limit: int | None = None,
        category: str | None = None,
    ) -> list[SIEMAlert]:
        """
        Get all alerts with optional filters.

        Args:
            limit: Maximum number of alerts to return (most recent first)
            category: Filter by category

        Returns:
            List of alerts
        """
        alerts = self.alerts

        if category:
            alerts = [a for a in alerts if a.category == category]

        # Return most recent first
        alerts = list(reversed(alerts))

        if limit:
            alerts = alerts[:limit]

        return alerts

    async def update_alert_status(
        self,
        alert_id: str,
        status: IncidentStatus,
        assigned_to: str = "",
        note: str = "",
    ) -> bool:
        """
        Update alert status and metadata.

        Args:
            alert_id: Alert ID to update
            status: New status
            assigned_to: Analyst assigned to investigate
            note: Optional note to add

        Returns:
            True if alert found and updated
        """
        for alert in self.alerts:
            if alert.alert_id == alert_id:
                alert.status = status
                if assigned_to:
                    alert.assigned_to = assigned_to
                if note:
                    alert.notes.append(f"{datetime.now()}: {note}")

                # Log status change
                await self.logger.log_audit(
                    message=f"SIEM alert {alert_id} status changed to {status.value}",
                    user=assigned_to or "system",
                    action="update_alert_status",
                    result="SUCCESS",
                    data={
                        "alert_id": alert_id,
                        "new_status": status.value,
                        "assigned_to": assigned_to,
                    },
                )

                self.logger.info(f"Alert {alert_id} status: {status.value}")
                return True

        return False

    # ----------------------------------------------------------------
    # Statistics and reporting
    # ----------------------------------------------------------------

    async def _update_statistics(self) -> None:
        """Update SIEM statistics in memory map."""
        active_alerts = self.get_active_alerts()

        self.memory_map["total_events_analyzed"] = self.total_events_analyzed
        self.memory_map["total_alerts_generated"] = self.total_alerts_generated
        self.memory_map["active_alerts"] = len(active_alerts)

        # Count by severity
        critical = sum(1 for a in active_alerts if a.severity == AlertSeverity.CRITICAL)
        high = sum(1 for a in active_alerts if a.severity == AlertSeverity.HIGH)
        medium = sum(1 for a in active_alerts if a.severity == AlertSeverity.MEDIUM)
        low = sum(1 for a in active_alerts if a.severity == AlertSeverity.LOW)

        self.memory_map["critical_alerts"] = critical
        self.memory_map["high_alerts"] = high
        self.memory_map["medium_alerts"] = medium
        self.memory_map["low_alerts"] = low

        # Update metadata
        self.metadata["total_alerts"] = self.total_alerts_generated
        self.metadata["active_alerts"] = len(active_alerts)

    def get_statistics(self) -> dict[str, Any]:
        """
        Get comprehensive SIEM statistics.

        Returns:
            Dictionary with SIEM metrics
        """
        active_alerts = self.get_active_alerts()

        return {
            "events": {
                "total_analyzed": self.total_events_analyzed,
                "analysis_interval": self.analysis_interval,
            },
            "alerts": {
                "total_generated": self.total_alerts_generated,
                "active": len(active_alerts),
                "by_severity": {
                    "critical": self.alert_count_by_severity[AlertSeverity.CRITICAL],
                    "high": self.alert_count_by_severity[AlertSeverity.HIGH],
                    "medium": self.alert_count_by_severity[AlertSeverity.MEDIUM],
                    "low": self.alert_count_by_severity[AlertSeverity.LOW],
                },
                "by_status": {
                    "new": sum(1 for a in self.alerts if a.status == IncidentStatus.NEW),
                    "investigating": sum(1 for a in self.alerts if a.status == IncidentStatus.INVESTIGATING),
                    "contained": sum(1 for a in self.alerts if a.status == IncidentStatus.CONTAINED),
                    "resolved": sum(1 for a in self.alerts if a.status == IncidentStatus.RESOLVED),
                },
            },
            "detection_rules": {
                "failed_auth_tracked": len(self._failed_auth_attempts),
                "network_violations_tracked": len(self._network_denials),
                "safety_bypasses_tracked": len(self._safety_bypasses),
            },
            "system": {
                "running": self._running,
                "last_analysis": self.metadata.get("last_scan_time"),
            },
        }

    def get_summary(self) -> str:
        """Get human-readable SIEM summary."""
        stats = self.get_statistics()
        active = stats["alerts"]["active"]
        critical = stats["alerts"]["by_severity"]["critical"]
        high = stats["alerts"]["by_severity"]["high"]

        return (
            f"SIEM System: {self.device_name}\n"
            f"  Events Analyzed: {stats['events']['total_analyzed']}\n"
            f"  Total Alerts: {stats['alerts']['total_generated']}\n"
            f"  Active Alerts: {active} "
            f"(Critical: {critical}, High: {high})\n"
            f"  Status: {'Running' if self._running else 'Stopped'}"
        )