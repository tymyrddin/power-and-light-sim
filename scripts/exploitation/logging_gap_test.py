#!/usr/bin/env python3
"""
Logging Gap Test: PLC Logic Modification
Tests whether PLC programming changes are logged and detected
"""

import time
from datetime import datetime
from typing import Any, cast

import pymodbus.exceptions as pymodbus_exceptions  # type: ignore
from pymodbus.client import ModbusTcpClient

# ============================================================================
# CONFIGURATION
# ============================================================================

CONFIG = {
    "plc": {
        "ip": "127.0.0.1",
        "port": 502,
        "vendor": "generic",
    },
    "test_actions": {
        "read_device_info": True,
        "read_program_info": True,
        "modify_register": True,
        "multiple_writes": True,
    },
    "logging_checks": {
        "plc_audit_log": True,
        "scada_logging": True,
        "siem_correlation": True,
        "network_ids": True,
        "file_integrity": True,
    },
}

# ============================================================================
# PLC INTERACTION FUNCTIONS
# ============================================================================


def connect_to_plc(ip: str, port: int) -> ModbusTcpClient:
    """
    Connect to PLC. This function guarantees that either the connection is
    established or raises an error, never returning None.
    """
    try:
        client = ModbusTcpClient(ip, port=port)
        if client.connect():
            print(f"[✓] Connected to PLC at {ip}:{port}")
            return client
        else:
            raise ConnectionError(f"Failed to connect to {ip}:{port}")
    except (ConnectionRefusedError, OSError) as e:
        raise ConnectionError(f"Network error: {e}") from e
    except Exception as e:
        raise RuntimeError(f"Unexpected error: {e}") from e


def read_plc_identification(client: ModbusTcpClient) -> dict[str, Any]:
    """
    Read the PLC identification info. Always returns a dictionary.
    """
    info: dict[str, Any] = {
        "success": False,
        "vendor": "Unknown",
        "model": "Unknown",
        "firmware": "Unknown",
        "registers_0_10": [],
    }

    try:
        result = client.read_holding_registers(0, 10)
        if not result.isError() and hasattr(result, "registers"):
            info["success"] = True
            info["registers_0_10"] = result.registers
            print(f"[✓] Read registers 0–10: {result.registers}")
        else:
            print("[✗] Could not read identification registers")
    except pymodbus_exceptions.ModbusException as e:
        print(f"[✗] Modbus error: {e}")
    except AttributeError as e:
        print(f"[✗] Attribute error: {e}")
    except Exception as e:
        print(f"[✗] Error: {e}")

    return info  # Always a dict, never None


def simulate_logic_modification(client: ModbusTcpClient) -> dict[str, Any]:
    """
    Simulate a logic modification by writing to registers. Always returns a dictionary.
    """
    results: dict[str, Any] = {
        "timestamp": datetime.now().isoformat(),
        "actions": [],
        "success": False,
        "successful_writes": 0,
        "verification": {},
    }

    # Step 1: Read current configuration
    try:
        current_config = client.read_holding_registers(1000, 20)
        if not current_config.isError() and hasattr(current_config, "registers"):
            results["actions"].append(
                {
                    "action": "read_configuration",
                    "success": True,
                    "registers": current_config.registers[:5],
                }
            )
        else:
            results["actions"].append(
                {"action": "read_configuration", "success": False}
            )
    except pymodbus_exceptions.ModbusException as e:
        results["actions"].append(
            {"action": "read_configuration", "success": False, "error": str(e)}
        )

    time.sleep(1)

    # Step 2: Modify registers
    modifications = [(1000, 9999), (1001, 8888), (1002, 7777)]
    for addr, val in modifications:
        try:
            result = client.write_register(addr, val)
            if not result.isError():
                results["actions"].append(
                    {
                        "action": "write_register",
                        "address": addr,
                        "value": val,
                        "success": True,
                    }
                )
                results["successful_writes"] += 1
            else:
                results["actions"].append(
                    {
                        "action": "write_register",
                        "address": addr,
                        "value": val,
                        "success": False,
                    }
                )
        except pymodbus_exceptions.ModbusException as e:
            results["actions"].append(
                {
                    "action": "write_register",
                    "address": addr,
                    "value": val,
                    "success": False,
                    "error": str(e),
                }
            )
        time.sleep(0.5)

    results["success"] = results["successful_writes"] > 0

    # Step 3: Verify modifications
    try:
        verify = client.read_holding_registers(1000, 3)
        if not verify.isError() and hasattr(verify, "registers"):
            results["verification"] = {"success": True, "values": verify.registers}
        else:
            results["verification"] = {"success": False}
    except pymodbus_exceptions.ModbusException as e:
        results["verification"] = {"success": False, "error": str(e)}

    return results  # Always a dict, never None


def check_logging_systems() -> dict[str, dict[str, str]]:
    """
    Check for logging gaps. Always returns a dictionary.
    """
    return {
        "plc_audit_log": {
            "expected": "Program modification event logged",
            "actual": "No audit log capability",
            "status": "NOT_LOGGED",
            "risk": "CRITICAL",
        },
        "scada_system": {
            "expected": "Configuration change event",
            "actual": "Does not monitor PLC programming operations",
            "status": "NOT_LOGGED",
            "risk": "HIGH",
        },
        "siem": {
            "expected": "Correlated engineering activity",
            "actual": "No PLC events available",
            "status": "NOT_LOGGED",
            "risk": "HIGH",
        },
        "network_ids": {
            "expected": "Detection of programming protocol",
            "actual": "No signatures for proprietary protocols",
            "status": "NOT_DETECTED",
            "risk": "HIGH",
        },
        "file_integrity": {
            "expected": "Program hash verification",
            "actual": "No integrity monitoring",
            "status": "NOT_MONITORED",
            "risk": "CRITICAL",
        },
        "change_management": {
            "expected": "Technical enforcement of change approval",
            "actual": "Policy-based only",
            "status": "NO_ENFORCEMENT",
            "risk": "HIGH",
        },
    }  # Always a dict, never None


def generate_recommendations() -> list[str]:
    """
    Generate security recommendations. Always returns a list.
    """
    return [
        "Enable PLC audit logging (if supported)",
        "Deploy passive OT protocol monitoring",
        "Implement PLC program integrity checks",
        "Require MFA for engineering access",
        "Digitally sign PLC program uploads",
        "Deploy OT-aware IDS (Claroty, Nozomi)",
        "Baseline PLC programs (write-once)",
        "Automate logic change detection",
        "Segment IT and OT networks",
        "Use jump hosts for engineering access",
    ]  # Always a list, never None


# ============================================================================
# MAIN TEST FUNCTION
# ============================================================================


def test_plc_logic_logging() -> dict[str, Any]:
    """
    Main test function for PLC logic modification logging.
    Returns the results dict.
    """
    results: dict[str, Any] = {
        "phases": {"identification": {}, "modification": {}},
        "logging_gaps": {},
        "recommendations": [],
        "error": None,
    }

    try:
        # Establish the connection to the PLC
        client = connect_to_plc(CONFIG["plc"]["ip"], CONFIG["plc"]["port"])

        # Run the test phases
        results["phases"]["identification"] = cast(
            dict[str, Any], read_plc_identification(client)
        )
        results["phases"]["modification"] = cast(
            dict[str, Any], simulate_logic_modification(client)
        )
        results["logging_gaps"] = cast(dict[str, Any], check_logging_systems())
        results["recommendations"] = cast(list[str], generate_recommendations())

        # Close the client connection at the end
        client.close()

    except Exception as e:
        results["error"] = str(e)

    return results  # Always returning Dict[str, Any]


# ============================================================================
# EXECUTION
# ============================================================================

if __name__ == "__main__":
    response = input("Proceed with logging gap test? (yes/no): ")
    if response.lower() in ("yes", "y"):
        print(test_plc_logic_logging())
    else:
        print("[*] Test cancelled")
